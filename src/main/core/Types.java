package core;

import static core.util.comparator.EqualityFunctions.EqualsCharSequenceCaseInSensitive;

/**
 * millemax
 * Date: 3/24/12
 * Time: 2:34 PM
 * <p/>
 * <p>
 * Jentry often deals with primitive types only to avoid having to wrap
 * items an Object's and all the allocation/gc associated with them.
 * </p>
 * <p>
 * The Types specify the specific primitive types, with a new type of
 * {@link CharSequence} and the common implementers (String is the most
 * well-know). Object is the last type, so when necessary to use Objects
 * or extending Objects, that is not prohibited.
 * </p>
 * <p/>
 * <p>Many of these methods will be added as necessary, and this class
 * will serve as a utility class for when dealing with different types
 * when the classes are not auto-generated by type.</p>
 */
public class Types
{
    public static final byte Bool = 1;
    public static final byte Char = 2;
    public static final byte Byte = 3;
    public static final byte Short = 4;
    public static final byte Int = 5;
    public static final byte Float = 6;
    public static final byte Double = 7;
    public static final byte Long = 8;
    public static final byte CharSequence = 9;
    public static final byte Object = 10;
    public static final byte Unknown = 11;


    public static byte getType( CharSequence name )
    {
        if( EqualsCharSequenceCaseInSensitive.equals( "Bool", name ) )
        {
            return Types.Bool;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Char", name ) )
        {
            return Types.Char;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Byte", name ) )
        {
            return Types.Byte;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Short", name ) )
        {
            return Types.Short;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Int", name ) )
        {
            return Types.Int;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Float", name ) )
        {
            return Types.Float;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Double", name ) )
        {
            return Types.Double;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Long", name ) )
        {
            return Types.Long;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "CharSequence", name ) )
        {
            return Types.CharSequence;
        }
        if( EqualsCharSequenceCaseInSensitive.equals( "Object", name ) )
        {
            return Types.Object;
        }
        return Types.Unknown;
    }

    public static CharSequence getName( byte type )
    {
        switch( type )
        {
            case Types.Bool:
                return "Boolean";
            case Types.Char:
                return "Char";
            case Types.Byte:
                return "Byte";
            case Types.Short:
                return "Short";
            case Types.Int:
                return "Int";
            case Types.Float:
                return "Float";
            case Types.Double:
                return "Double";
            case Types.Long:
                return "Long";
            case Types.CharSequence:
                return "CharSequence";
            case Types.Object:
                return "Object";
            default:
                throw new IllegalArgumentException( "Not a valid type" );
        }
    }


}
