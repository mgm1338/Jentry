Introduction to Jentry

Jentry is a light-weight Java framework designed for efficient store and processing of flows of information. Designed originally for the financial industry, the collections
and ideas are designed for processing millions of records in memory in sub-second times. 


I originally encountered the ideas for the Jentry framework while helping develop a similar framework at a multinational investment bank. The framework's purpose was to greatly 
improve the performance of many trading applications. This style of framework had proven successful in before in other financial institutions, and many of the other
developers had been poached from these successful frameworks of the past. For about two years (and many re-written components), where the framework was employed in tens
of internal applications. 

In the end, we had some success, but the framework's development was largely driven by the internal groups at the bank. Everyone demanded their application's features be pushed
into the development path, so quickly what began as a few simple cool ideas became a clutter of random purposes. The essence of the framework was quickly obfiscated by 
unnecessary features. As you may have heard in the news, the past few years the banks have had to cut some costs. Our framework was shipped off to Russia, where the original intent of the framework was 
completely lost and gutted. Now most of the developers, like myself, have spread to different jobs (with much more mundance purpose).

The internal framework, with all its faults, was pretty sweet. It has a lot of complexity, but it also very powerful. With the boring subject of my current job, I decided
to start working on a replacement with a much lighter footprint. After much deliberation, I decided on the name Jentry (which will be explained later, but I am very proud
of this name). 


Few Basic Pricincples of Jentry:

- Memory efficiency

Jentry is array-based and based on the primitive arrays. When starting to store millions of record in memory, Object allocation and garbage collection can often 
become a large drain (in many cases the largest) on resources. In this way, Jentry Collections are similar to the GNU trove framework. The collections are designed to be faster and use less memory
than the standard JDK collections. Trove explains this tenant in a very succinct way in its second objective:

	Whenever possible, provide the same collections support for primitive types. This gap in the JDK is often addressed by using the "wrapper" 
	classes (java.lang.Integer, java.lang.Float, etc.) with Object-based collections. For most applications, however, collections which store primitives 
	directly will require less space and yield significant performance gains.


Jentry Collections expands on this idea, with a couple wrinkles that makes it ideal for in-memory data stores (or else I would have simply stolen the Trove Collections). 
This will be discussed as a great length with many examples, however
it is easiest to get the gist in a couple examples.

	Example 1:
	
	Suppose that you want to quickly process an ASCII text, recording the number of occurences of a letter in the text. Suppose  memory efficiency is
	king, and any trick to store the data efficiently is ideal. A good solution would be to allocate an array of the valid ascci slots, do one pass over the text, and do something
	along the order of:

	CharSequence text;
	long[] occurances = new long[74]; //index 0 = 48 (code for 0), index 73 = 122 (code for z)
	
	int len = text.length();
	for (int i =0; i< len; i++)
	{
		byte c = text.charAt(i);
		if (c > 47 && c < 122)
		{
			occurances[c-48]++;
		}	
	}

	This way is quick, passing over the text once, and allocates one array. Every character has to be part of the 74 characters, and we can simply retrieve the 
	number of 'a's in the text by getting the value of occurances of the ascii code - 48 (so occurances[97-48]). The idea is simple, we use the index of the 
	occurances array to store information, in this case the index of the array corresponds to the ASCII code. 

	Every slot in the array is going to be used, which we would call 'compactness' in our framework. The indirection to the index or slot in the array (in this case,
	the ASCII code - 48) will be called an entry. This is the reasons that it is called Jentry, for J-entry (the snobby play on the word Gentry with a J is just a 
	delightful coincidence). 

	

		


	