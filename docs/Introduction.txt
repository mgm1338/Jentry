Introduction to Jentry

Jentry is a light-weight Java framework designed for efficient store and processing of flows of information. Designed originally for the financial industry, the collections
and ideas are ideal for processing millions of records in memory in sub-second times. 


I originally encountered the ideas for the Jentry framework while developing an internal framework at a multinational investment bank. The framework's purpose was to greatly 
improve the efficiency and performance of many trading applications. The ideas at the framework had proven successful in before in other financial institutions, so we tried
to replicate some of the practices and standards that worked well, while adding our own improvements to the mix. 

In the end, we had some success, but the framework's development was driven by the internal groups at the bank. Everyone demanded their application's features be developed by
our group (often at the same time), so quickly what began as a few simple cool ideas became a clutter of random purposes. The essence of the framework was quickly obfiscated by 
unnecessary features and in a time of trying to cut costs as quickly as possible, the framework was shipped off to Russia, where the original intent of the framework was 
completely lost and gutted. 


Jentry is a bit different. As there are no stakeholders forcing features and releases, the mission is to be much clearer, with a few basic principles.

- Memory efficiency

Jentry is array-based and based on the primitive arrays. When starting to store millions of record in memory, Object allocation and garbage collection can often 
become the largest cost of resources. In this way, Jentry Collections are similar to the GNU trove framework. The collections are designed to be faster and use less memory
than the standard JDK collections. Trove explains this tenant in a very succinct way in its second objective:

	Whenever possible, provide the same collections support for primitive types. This gap in the JDK is often addressed by using the "wrapper" 
	classes (java.lang.Integer, java.lang.Float, etc.) with Object-based collections. For most applications, however, collections which store primitives 
	directly will require less space and yield significant performance gains.


Jentry expands on this idea, with a couple wrinkles that makes it ideal for in-memory data stores. This will be discussed as a great length with many examples, however
it is easiest to get the gist in a couple examples.

	Example 1:
	
	Suppose that you want to quickly process an ASCII text, recording the number of occurences of a letter in the text. Suppose this is many years ago, where memory efficiency was
	king, and any trick to store the data efficiently is ideal. A good solution would be to allocate an array of the valid ascci slots, do one pass over the text, and do something
	along the order of:

	CharSequence text;
	long[] occurances = new long[74]; //index 0 = 48 (code for 0), index 73 = 122 (code for z)
	
	int len = text.length();
	for (int i =0; i< len; i++)
	{
		byte c = text.charAt(i);
		if (c > 47 && c < 122)
		{
			occurances[c-48]++;
		}	
	}

	This way is quick, passing over the text once, and allocates one array. Every character has to be part of the 74 characters, and we can simply retrieve the 
	number of 'a's in the text by getting the value of occurances of the ascii code - 48 (so occurances[97-48]). The idea is simple, we use the index of the 
	occurances array to store information, in this case the index of the array corresponds to the ASCII code. 

	Every slot in the array is going to be used, which we would call 'compactness' in our framework. The indirection to the index or slot in the array (in this case,
	the ASCII code - 48) will be called an entry. This is the reasons that it is called Jentry, for J-entry (the snobby play on the word Gentry with a J is just a 
	delightful coincidence). 

	

		


	